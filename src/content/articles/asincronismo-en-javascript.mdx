---
title: ¿Qué es el asincronismo en JavaScript?
authors:
  - allanjuarez
pubDate: August/25/2025
category: javascript
cover:
  img: src/assets/await.png
  description: Default
thumbnail:
  img: src/assets/await.png
  description: Default
relatedArticles:
  - que-son-y-para-que-sirven-los-middelwares-de-nextjs
  - como-funcionan-las-custom-properties-de-css
---

import CodeBlock from '@components/blog/CodeBlock.astro'
import Heading2 from '@components/blog/Heading2.astro'
import Heading3 from '@components/blog/Heading3.astro'
import Paragraph from '@components/blog/Paragraph.astro'
import List from '@components/blog/List.astro'
export const components = { h2: Heading2, h3: Heading3, p: Paragraph, ul: List }

Cuando empezamos a programar en JavaScript, uno de los conceptos que más confunde es el asincronismo. ¿Qué significa que algo sea “asíncrono”? ¿Por qué a veces el código no se ejecuta en el orden que esperábamos? Y, sobre todo, ¿cómo podemos controlarlo sin volvernos locos?

En este artículo vamos a repasar, paso a paso, cómo funciona el asincronismo en JavaScript, con ejemplos claros que puedes probar tú mismo.

## JavaScript y su naturaleza “single-thread”

Primero lo básico: JavaScript es un lenguaje single-threaded, es decir, solo puede ejecutar una cosa a la vez. Entonces, ¿cómo puede hacer varias tareas “al mismo tiempo”?

La respuesta está en que delega ciertas operaciones —como esperar la respuesta de un servidor o contar un temporizador— al navegador o al entorno de ejecución (Node.js, por ejemplo). De esta manera, JavaScript no se queda “congelado” y puede seguir ejecutando el resto del código.

export const example1 = `// Ejemplo síncrono
console.log("Inicio");
for (let i = 0; i < 3; i++) {
  console.log("Contando:", i);
}
console.log("Fin");
}`.trim()

export const result1 = `Inicio
Contando: 0
Contando: 1
Contando: 2
Fin`.trim()

<CodeBlock lang='js' code={example1} />

El resultado sera:

<CodeBlock lang='js' code={result1} />

Ahora comparemos con algo asíncrono:

export const example2 =
`
// Ejemplo asíncrono
console.log("Inicio");
setTimeout(() => {
  console.log("Esto tarda 2 segundos");
}, 2000);
console.log("Fin");
`.trim()

export const result2 = 
`
Inicio
Fin
Esto tarda 2 segundos
`.trim()

<CodeBlock lang='js' code={example2} />

Y su resultado:

<CodeBlock lang='js' code={result2} />

Como ves, el programa no se detiene esperando el setTimeout. Continúa y, cuando la tarea termina, ejecuta el callback.

## Callbacks: el origen del asincronismo

La forma más antigua de manejar código asíncrono en JavaScript es usando callbacks: funciones que se ejecutan cuando otra tarea finaliza.

export const example3 =
`
function obtenerDatos(callback) {
  console.log("Consultando servidor...");
  setTimeout(() => {
    callback("Datos recibidos");
  }, 1500);
}

obtenerDatos((resultado) => {
  console.log(resultado);
});
`.trim()

<CodeBlock lang='js' code={example3} />

El problema aparece cuando necesitas encadenar muchas operaciones. El código termina lleno de funciones dentro de funciones, lo que se conoce como callback hell.

## Promesas: una solución más elegante

Para resolver ese caos, llegaron las promesas. Una promesa es un objeto que representa un valor que estará disponible ahora, más tarde o nunca.


export const example4 =
`
function obtenerUsuario() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve({ id: 1, nombre: "Allan" });
    }, 2000);
  });
}

obtenerUsuario()
  .then((usuario) => {
    console.log("Usuario:", usuario);
  })
  .catch((error) => {
    console.error("Error:", error);
  });
`.trim()

<CodeBlock lang='js' code={example4} />

Gracias a then y catch el código se vuelve más ordenado y mucho más legible que con callbacks anidados.

## Async / Await: sintaxis moderna y clara 

Desde ES2017 tenemos async/await, una forma de escribir código asíncrono con una sintaxis que parece “síncrona”. Esto hace que sea más fácil de leer y mantener.

export const example5 =
`
async function mostrarUsuario() {
  try {
    console.log("Obteniendo usuario...");
    const usuario = await obtenerUsuario(); // espera la promesa
    console.log("Usuario recibido:", usuario);
  } catch (error) {
    console.error("Hubo un error:", error);
  }
}

mostrarUsuario();
`.trim()

<CodeBlock lang='js' code={example5} />

Con await, el programa se “pausa” dentro de la función hasta que la promesa se resuelve, pero sin bloquear el hilo principal.


### Conclusión

El asincronismo puede parecer complicado al principio, pero en realidad es lo que hace que JavaScript sea tan poderoso en el desarrollo web.

- Con callbacks se dio el primer paso.
- Con promesas el código ganó claridad.
- Y con async/await escribir funciones asíncronas se volvió mucho más natural.

Si entiendes cómo y cuándo usar estas herramientas, estarás listo para trabajar con APIs, peticiones HTTP, bases de datos y cualquier tarea que requiera esperar resultados sin congelar tu aplicación.