---
import ObserverLink from './ObserverLink.astro'

interface Props {
  categories: {
    id: number
    name: string
  }[]
  class?: string | null | undefined
}
// sticky top-0
const { categories, class: className, ...props } = Astro.props
---

<div
  id='PrimaryFiltersWrapper'
  class:list={[
    'h-full mb-8 py-8 px-6 flex flex-row gap-8 bg-gray-1000/50 backdrop-blur-3xl lg:mb-0 lg:pl-0 lg:pr-32 lg:py-16 lg:flex-col',
    className,
  ]}
  {...props}>
  <ObserverLink
    ref={`?category=${categories[0].name}`}
    type='local'
    class='h-fit text-md lg:text-lg xl:text-xl'
    data-value={categories[0].name}
    >{categories[0].name.split('').with(0, categories[0].name[0].toUpperCase())}</ObserverLink
  >
  <div class='overflow-y-hidden overflow-x-auto lg:overflow-x-hidden scrollbar'>
    <div id='PrimaryFilters' class='flex flex-row gap-8 lg:flex-col'>
      {
        categories.map(category => {
          // with(index, newElement) | No mutable
          // Metodo de arrays que retorna una copia exacta del array original solo modificando un indice dado.
          // .with(0, category.name[0].toUpperCase())
          const categoryDisplayName = category.name
            .split('')
            .with(0, category.name[0].toUpperCase())

          if (category.name !== 'latest') {
            return (
              <ObserverLink
                ref={`?category=${category.name}`}
                type='local'
                class='text-md lg:text-lg xl:text-xl'
                data-value={category.name}>
                {categoryDisplayName}
              </ObserverLink>
            )
          }
        })
      }
    </div>
  </div>
</div>

<script>
  import { markActiveLink } from '@lib/dom/blog'
  import type { AstroNode, AstroNodeList, UrlChangeEventData } from '@custom-types/global'

  // Set Url
  function setUrlByFilterData(filters: AstroNodeList): void {
    if (!filters) return

    filters?.forEach(node => {
      // getAttribute(<attribute>)
      // Retorna el valor de un atributo, si el atributo no existe retorna null.
      const filterData = node.getAttribute('data-value')

      if (!filterData) return

      node.addEventListener('click', e => {
        // Previene el comportamiento "natural" del elemento html, en este caso el anchor no actualizara la pagína.
        e.preventDefault()

        const url = new URL(window.location.href)
        // Obtiene el valor de un search param de la URL.
        const currentFilter = url.searchParams.get('category')

        if (filterData === currentFilter) {
          url.searchParams.delete('category')
          window.history.pushState({}, '', url)

          window.dispatchEvent(
            new CustomEvent('changeUrl', { detail: { payload: url.searchParams.get('category') } }),
          )

          return
        } else {
          url.searchParams.set('category', filterData)

          // history.pushState(state, unused, url?)
          // Metodo que permite agregar al historial de navegación una nueva entrada.
          // url: es la nueva entrada que se agregara al navegador, debe ser del mismo origen si no genera una excepción, si no se agrega por defecto define la URL actual.
          window.history.pushState({}, '', url)

          window.dispatchEvent(
            new CustomEvent('changeUrl', { detail: { payload: url.searchParams.get('category') } }),
          )
        }
      })
    })
  }

  // Sync active filter on load
  function syncActiveFilterOnLoad(filters: AstroNodeList) {
    if (!filters) return

    const url = new URL(window.location.href)
    const currentUrlCategory = url.searchParams.get('category')

    for (const filter of Array.from(filters)) {
      const currentFilterValue = filter.dataset.value
      const isActive = currentFilterValue === currentUrlCategory

      markActiveLink(filter, isActive)

      const parent = filter.parentNode
      if (parent?.firstElementChild !== filter && currentFilterValue !== 'latest' && isActive) {
        parent?.insertBefore(filter, parent.firstElementChild)
      }
    }

    window.scrollTo({ top: 0, left: 0, behavior: 'smooth' })
    primaryFiltersInner?.scrollTo({ left: 0, behavior: 'smooth' })
  }

  // Sync primary filters
  function syncActiveFilterByUrl({
    filters,
    currentUrlCategory,
  }: {
    filters: AstroNodeList
    currentUrlCategory: string | null
  }) {
    if (!filters) return

    for (const filter of Array.from(filters)) {
      const currentFilterValue = filter.dataset.value //data-*
      const isActive = currentFilterValue === currentUrlCategory

      markActiveLink(filter, isActive)

      // .parentNode
      // Propiedad que devuelve el padre de un elemento hijo, si el elemento se acaba de crear sin tener un arbol asociado o no tiene padre retorna null.
      const parent = filter.parentNode
      // reorder()
      if (parent?.firstElementChild !== filter && currentFilterValue !== 'latest' && isActive) {
        // insertBefore(newNode, OldNode)
        // Inserta un elemento antes que otro ya existente.
        parent?.insertBefore(filter, parent.firstElementChild)
      }
    }
  }

  const primaryFiltersWrapper: AstroNode = document.querySelector('#PrimaryFiltersWrapper')
  const primaryFiltersInner: AstroNode | undefined = primaryFiltersWrapper?.querySelector(
    '#PrimaryFiltersWrapper > div',
  )
  const allFilters: AstroNodeList | undefined =
    primaryFiltersWrapper?.querySelectorAll('a[data-value]')

  syncActiveFilterOnLoad(allFilters)
  setUrlByFilterData(allFilters)

  window.addEventListener('changeUrl', e => {
    const event = e as CustomEvent<UrlChangeEventData>
    const payload = event.detail.payload

    syncActiveFilterByUrl({ filters: allFilters, currentUrlCategory: payload })
    window.scrollTo({ top: 0, left: 0, behavior: 'smooth' })
    primaryFiltersInner?.scrollTo({ left: 0, behavior: 'smooth' })
  })
</script>
